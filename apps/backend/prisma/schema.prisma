// Prisma Schema for Solana Micro-Paywall Platform
// This schema defines the core data model for merchants, payments, access tokens, and ledger tracking.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// Merchant & Content Management
// ============================================================================

model Merchant {
  id             String   @id @default(cuid())
  email          String   @unique
  status         String   @default("pending") // pending, active, suspended, kyc_required
  payoutAddress  String?  // Solana wallet address for payouts
  webhookSecret  String?  // HMAC secret for webhook verification
  configJson     Json?    // Widget configuration, branding, etc.
  
  // Profile fields
  displayName    String?  // Public display name
  bio            String?  // Merchant bio/description
  avatarUrl      String?  // Profile picture URL
  websiteUrl     String?  // Personal/company website
  twitterUrl      String?  // Twitter/X profile URL
  telegramUrl    String?  // Telegram channel/group URL
  discordUrl     String?  // Discord server URL
  githubUrl      String?  // GitHub profile URL
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  contents       Content[]
  paymentIntents PaymentIntent[]
  accessTokens   AccessToken[]
  refundRequests RefundRequest[]
  purchases      Purchase[]
  followers      MerchantFollow[]
  referralCodes  ReferralCode[]
  apiKeys        ApiKey[]

  @@index([email])
  @@index([status])
}

model Content {
  id           String   @id @default(cuid())
  merchantId   String
  slug         String
  priceLamports BigInt   // Price in lamports (1 SOL = 1e9 lamports)
  currency     String   @default("SOL") // SOL, USDC, PYUSD
  durationSecs Int?     // Access duration in seconds (null = one-time)
  metadata     Json?    // Additional content metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Discovery & Presentation Fields
  title        String?  // Human-readable title (e.g., "Advanced Solana Development Guide")
  description  String?  // Short description for listings
  thumbnailUrl String?  // Image URL for marketplace cards
  category     String?  // Category: "article", "video", "course", "api", "download", "subscription"
  tags         String[] @default([]) // Array of tags for search/filtering
  visibility   String   @default("private") // "public", "private", "unlisted"
  canonicalUrl String?  // Original content URL (if hosted elsewhere)
  previewText  String?  // Free preview text (first paragraph, etc.)
  
  // Analytics
  viewCount    Int      @default(0)
  purchaseCount Int     @default(0) // Derived from payment count

  // Relations
  merchant      Merchant        @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  paymentIntents PaymentIntent[]
  purchases     Purchase[]
  bookmarks     Bookmark[]

  @@unique([merchantId, slug])
  @@index([merchantId])
  @@index([visibility])
  @@index([category])
  @@index([createdAt])
}

// ============================================================================
// Payment Flow
// ============================================================================

model PaymentIntent {
  id          String   @id @default(cuid())
  merchantId  String
  contentId   String
  memo        String   @unique // Unique memo binding payment to intent
  nonce       String   @unique // Additional nonce for replay protection
  amount      BigInt   // Amount in lamports
  currency    String   @default("SOL")
  payerWallet String?  // Optional: wallet address that initiated
  status      String   @default("pending") // pending, confirmed, failed, expired
  createdAt   DateTime @default(now())
  expiresAt   DateTime // Expiration timestamp
  confirmedAt DateTime?

  // Relations
  merchant    Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  content     Content   @relation(fields: [contentId], references: [id], onDelete: Cascade)
  payment     Payment?

  @@index([merchantId])
  @@index([contentId])
  @@index([memo])
  @@index([status])
  @@index([createdAt])
}

model Payment {
  id            String   @id @default(cuid())
  intentId      String   @unique
  txSignature   String   @unique // Solana transaction signature
  payerWallet   String   // Wallet that made the payment
  amount        BigInt   // Confirmed amount in lamports
  currency      String   @default("SOL")
  confirmedAt   DateTime @default(now())
  blockTime     BigInt?  // Solana block time
  slot          BigInt?  // Solana slot number

  // Relations
  intent        PaymentIntent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  accessToken   AccessToken?
  refundRequests RefundRequest[]
  purchase      Purchase?

  @@index([txSignature])
  @@index([payerWallet])
  @@index([confirmedAt])
  @@index([intentId])
}

// ============================================================================
// Access Control
// ============================================================================

model AccessToken {
  id         String   @id @default(cuid())
  merchantId String
  contentId  String?
  paymentId  String?  @unique
  tokenJti   String   @unique // JWT JTI (JWT ID) claim
  expiresAt  DateTime
  redeemedAt DateTime?
  createdAt  DateTime @default(now())

  // Relations
  merchant      Merchant       @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  payment       Payment?       @relation(fields: [paymentId], references: [id], onDelete: SetNull)
  stripeReceipt StripeReceipt?
  purchase      Purchase?

  @@index([tokenJti])
  @@index([merchantId])
  @@index([expiresAt])
}

// ============================================================================
// Buyer Purchase Tracking
// ============================================================================

model Purchase {
  id            String   @id @default(cuid())
  walletAddress String   // Buyer's wallet address
  paymentId     String   @unique
  contentId     String
  merchantId    String
  accessTokenId String?   @unique
  purchasedAt   DateTime @default(now())
  expiresAt     DateTime?
  
  // Relations
  content       Content      @relation(fields: [contentId], references: [id], onDelete: Cascade)
  merchant      Merchant     @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  payment       Payment      @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  accessToken   AccessToken?  @relation(fields: [accessTokenId], references: [id], onDelete: SetNull)
  referral      Referral?

  @@index([walletAddress])
  @@index([contentId])
  @@index([merchantId])
  @@index([purchasedAt])
}

model Bookmark {
  id            String   @id @default(cuid())
  walletAddress String
  contentId     String
  createdAt     DateTime @default(now())
  
  // Relations
  content       Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@unique([walletAddress, contentId])
  @@index([walletAddress])
  @@index([contentId])
}

model MerchantFollow {
  id            String   @id @default(cuid())
  walletAddress String
  merchantId    String
  createdAt     DateTime @default(now())
  
  // Relations
  merchant      Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([walletAddress, merchantId])
  @@index([walletAddress])
  @@index([merchantId])
}

// ============================================================================
// Refunds & Reconciliation
// ============================================================================

model RefundRequest {
  id          String   @id @default(cuid())
  merchantId  String
  paymentId   String
  type        String   // "on_chain", "off_chain", "credit"
  status      String   @default("pending") // pending, processing, completed, failed
  reason      String?
  refundTxSignature String? // On-chain refund transaction signature
  processedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  merchant    Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  payment     Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([merchantId])
  @@index([paymentId])
  @@index([status])
}

// ============================================================================
// Optional: Stripe Fallback (Future Enhancement)
// ============================================================================

model StripeReceipt {
  id          String   @id @default(cuid())
  stripeSessionId String @unique
  merchantId  String
  contentId   String?
  amount      BigInt
  currency    String
  payerEmail  String?
  accessTokenId String? @unique
  createdAt   DateTime @default(now())

  accessToken AccessToken? @relation(fields: [accessTokenId], references: [id], onDelete: SetNull)

  @@index([stripeSessionId])
  @@index([merchantId])
}

// ============================================================================
// Analytics & Audit
// ============================================================================

model DashboardEvent {
  id         String   @id @default(cuid())
  merchantId String?
  eventType  String   // "payment_created", "payment_confirmed", "token_redeemed", etc.
  metadata   Json?
  createdAt  DateTime @default(now())

  @@index([merchantId])
  @@index([eventType])
  @@index([createdAt])
}

model LedgerEvent {
  id           String   @id @default(cuid())
  eventType    String   // "payment_intent_created", "payment_confirmed", "token_issued", "refund_processed"
  entityType   String   // "payment_intent", "payment", "access_token", "refund"
  entityId     String
  previousState Json?
  newState     Json
  metadata     Json?
  createdAt    DateTime @default(now())

  @@index([eventType])
  @@index([entityType, entityId])
  @@index([createdAt])
}

// ============================================================================
// Referral System
// ============================================================================

model ReferralCode {
  id            String   @id @default(cuid())
  code          String   @unique // Unique referral code
  merchantId    String?  // Optional: merchant-specific code
  referrerWallet String?  // Optional: wallet that created this code
  discountPercent Int?    // Discount percentage (0-100)
  discountAmount BigInt?  // Fixed discount amount in lamports
  maxUses       Int?      // Maximum number of uses (null = unlimited)
  currentUses   Int       @default(0)
  expiresAt     DateTime? // Optional expiration date
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  merchant      Merchant? @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  referrals     Referral[]

  @@index([code])
  @@index([merchantId])
  @@index([referrerWallet])
  @@index([isActive])
}

model Referral {
  id            String   @id @default(cuid())
  referralCodeId String
  referrerWallet String  // Wallet that shared the code
  refereeWallet  String  // Wallet that used the code
  purchaseId     String? @unique // Purchase made with referral
  rewardAmount   BigInt?  // Reward given to referrer (in lamports)
  discountAmount BigInt?  // Discount applied to referee (in lamports)
  createdAt      DateTime @default(now())

  // Relations
  referralCode  ReferralCode @relation(fields: [referralCodeId], references: [id], onDelete: Cascade)
  purchase      Purchase?    @relation(fields: [purchaseId], references: [id], onDelete: SetNull)

  @@index([referralCodeId])
  @@index([referrerWallet])
  @@index([refereeWallet])
  @@index([createdAt])
}

// ============================================================================
// API Keys System
// ============================================================================

model ApiKey {
  id            String   @id @default(cuid())
  merchantId    String
  name          String   // User-friendly name for the key
  keyHash       String   @unique // Hashed API key (never store plain text)
  keyPrefix     String   // First 8 chars for display (e.g., "sk_live_...")
  isActive      Boolean  @default(true)
  lastUsedAt    DateTime? // Last time the key was used
  rateLimit     Int?     // Custom rate limit (requests per minute)
  allowedIps    String[] @default([]) // Optional IP whitelist
  createdAt     DateTime @default(now())
  expiresAt     DateTime? // Optional expiration date

  // Relations
  merchant      Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  usageLogs     ApiKeyUsage[]

  @@index([merchantId])
  @@index([keyHash])
  @@index([isActive])
}

model ApiKeyUsage {
  id            String   @id @default(cuid())
  apiKeyId      String
  endpoint      String   // API endpoint accessed
  method        String   // HTTP method
  statusCode    Int      // HTTP status code
  responseTime  Int?     // Response time in ms
  ipAddress     String?  // Client IP address
  userAgent     String?  // User agent
  createdAt     DateTime @default(now())

  // Relations
  apiKey        ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@index([apiKeyId])
  @@index([createdAt])
  @@index([endpoint])
}

