name: Deploy Converged Workers + Pages

on:
  push:
    branches:
      - main
    paths:
      - 'apps/web/**'
      - 'apps/backend-workers/**'
      - 'wrangler.toml'
      - 'package.json'
      - 'package-lock.json'
      - '.npmrc'
      - '.github/workflows/deploy-converged.yml'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    name: Deploy Converged Workers + Pages
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Enable Corepack
        run: corepack enable

      - name: Configure npm for peer dependencies
        run: npm config set legacy-peer-deps true
      
      - name: Install dependencies
        run: npm ci

      - name: Clean previous builds
        working-directory: apps/web
        run: |
          rm -rf .next .cache .vercel
          echo "‚úÖ Cleaned previous build artifacts"

      - name: Build Next.js app for Cloudflare Pages
        working-directory: apps/web
        env:
          # Note: Linter warnings about context access are expected - secrets may not exist but defaults are provided
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL || 'https://api.micropaywall.app' }}
          NEXT_PUBLIC_SOLANA_RPC: ${{ secrets.NEXT_PUBLIC_SOLANA_RPC || 'https://api.devnet.solana.com' }}
          NEXT_PUBLIC_SOLANA_RPC_MAINNET: ${{ secrets.NEXT_PUBLIC_SOLANA_RPC_MAINNET || 'https://api.mainnet-beta.solana.com' }}
          NEXT_PUBLIC_SOLANA_NETWORK: ${{ secrets.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet' }}
          NEXT_PUBLIC_WEB_URL: ${{ secrets.NEXT_PUBLIC_WEB_URL || 'https://micropaywall.app' }}
          # Disable all caching to prevent large cache files
          NEXT_CACHE: false
          WEBPACK_CACHE: false
          # Skip Sentry during Cloudflare build to avoid module resolution errors
          SKIP_SENTRY: 'true'
          BUILD_ID: ${{ github.sha }}
        run: |
          set -x
          echo "::group::üî® Building Next.js app for Converged Workers + Pages"
          echo "=========================================="
          echo "Build Step Starting"
          echo "=========================================="
          echo ""
          
          echo "::group::üìã Step 1: Running Next.js build"
          echo "Running: npm run build"
          npm run build
          BUILD_EXIT_CODE=$?
          echo "Next.js build exit code: $BUILD_EXIT_CODE"
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Next.js build failed with exit code $BUILD_EXIT_CODE"
            exit 1
          fi
          echo "‚úÖ Next.js build completed successfully"
          echo "::endgroup::"
          echo ""
          
          echo "::group::üìã Step 2: Running @cloudflare/next-on-pages"
          echo "This generates functions for edge runtime pages"
          echo "Running: npx @cloudflare/next-on-pages@latest"
          echo ""
          npx @cloudflare/next-on-pages@latest
          NEXT_ON_PAGES_EXIT_CODE=$?
          echo ""
          echo "@cloudflare/next-on-pages exit code: $NEXT_ON_PAGES_EXIT_CODE"
          if [ $NEXT_ON_PAGES_EXIT_CODE -ne 0 ]; then
            echo "‚ùå @cloudflare/next-on-pages failed with exit code $NEXT_ON_PAGES_EXIT_CODE"
            exit 1
          fi
          echo "‚úÖ @cloudflare/next-on-pages completed successfully"
          echo "::endgroup::"
          echo ""
          
          echo "‚úÖ Build completed successfully"
          echo "::endgroup::"

      - name: Install Wrangler CLI
        run: |
          echo "üì¶ Installing Wrangler CLI..."
          npm install -g wrangler
          wrangler --version

      - name: Verify build output
        working-directory: apps/web
        run: |
          echo "üîç Verifying build output..."
          if [ ! -d ".vercel/output" ]; then
            echo "‚ùå .vercel/output directory not found!"
            exit 1
          fi
          echo "‚úÖ .vercel/output directory exists"
          echo ""
          echo "üìÅ Root contents:"
          ls -la .vercel/output/ | head -20
          echo ""
          echo "üìÅ Static directory:"
          if [ -d ".vercel/output/static" ]; then
            echo "‚úÖ Static directory exists"
            ls -la .vercel/output/static/ | head -10
            if [ -f ".vercel/output/static/index.html" ]; then
              echo "‚úÖ index.html found in static/"
            else
              echo "‚ö†Ô∏è  index.html not found in static/"
            fi
          else
            echo "‚ùå No static directory found - deployment will fail!"
            exit 1
          fi
          echo ""
          echo "üìÅ Functions directory:"
          if [ -d ".vercel/output/functions" ]; then
            echo "‚úÖ Functions directory exists"
            ls -la .vercel/output/functions/ | head -10
            echo ""
            echo "üîé Functions directory (dashboard/bookmarks/not-found mapping):"
            ls -la .vercel/output/functions/ | grep -E "dashboard|bookmarks|_not-found|index|middleware" || true
            echo ""
            echo "üìÅ Functions directory (first 200 entries):"
            ls -la .vercel/output/functions/ | head -200
          else
            echo "‚ö†Ô∏è  No functions directory (may be OK for static pages)"
          fi
          echo ""
          echo "üìÅ Root-level files:"
          if [ -f ".vercel/output/index.html" ]; then
            echo "‚úÖ Root-level index.html exists"
          else
            echo "‚ö†Ô∏è  No root-level index.html (may need to copy from static/)"
            if [ -f ".vercel/output/static/index.html" ]; then
              echo "   Copying static/index.html to root..."
              cp .vercel/output/static/index.html .vercel/output/index.html
              echo "   ‚úÖ Copied"
            fi
          fi

          echo ""
          echo "üìÑ RSC entry files (CRITICAL for App Router on Cloudflare):"
          # next-on-pages/OpenNext style config.json routes often point to "/index.rsc" and "/$route.rsc"
          # Those files may be emitted into static/. Ensure they exist at the output root where routes expect them.
          if [ -d ".vercel/output/static" ]; then
            echo "   Searching for *.rsc / *.prefetch.rsc / *.action under static/..."
            RSC_COUNT=$(find .vercel/output/static -maxdepth 2 -type f \( -name "*.rsc" -o -name "*.prefetch.rsc" -o -name "*.action" \) 2>/dev/null | wc -l)
            echo "   Found $RSC_COUNT candidate files"
            if [ "$RSC_COUNT" -gt 0 ]; then
              echo "   Copying missing RSC-related files to root..."
              find .vercel/output/static -maxdepth 2 -type f \( -name "*.rsc" -o -name "*.prefetch.rsc" -o -name "*.action" \) 2>/dev/null | while read -r f; do
                base=$(basename "$f")
                if [ ! -f ".vercel/output/$base" ]; then
                  cp "$f" ".vercel/output/$base"
                fi
              done
              echo "   ‚úÖ Copy complete"
              echo "   Root RSC files now present:"
              ls -la .vercel/output/ | grep -E \"\\.rsc$|\\.prefetch\\.rsc$|\\.action$\" | head -200 || true
            fi
          fi
          echo ""
          echo "üìÅ _next directory (CRITICAL for static assets):"
          if [ -d ".vercel/output/_next" ]; then
            echo "‚úÖ Root-level _next directory exists"
            JS_COUNT=$(find .vercel/output/_next/static -name "*.js" 2>/dev/null | wc -l)
            CSS_COUNT=$(find .vercel/output/_next/static -name "*.css" 2>/dev/null | wc -l)
            echo "   Found: $JS_COUNT JS files, $CSS_COUNT CSS files"
          else
            echo "‚ö†Ô∏è  No root-level _next directory - copying from static/..."
            if [ -d ".vercel/output/static/_next" ]; then
              echo "   Copying static/_next to root level..."
              cp -r .vercel/output/static/_next .vercel/output/_next
              echo "   ‚úÖ Copied _next directory to root level"
              echo "   This ensures CSS/JS assets are accessible at /_next/static/..."
              JS_COUNT=$(find .vercel/output/_next/static -name "*.js" 2>/dev/null | wc -l)
              CSS_COUNT=$(find .vercel/output/_next/static -name "*.css" 2>/dev/null | wc -l)
              echo "   Found: $JS_COUNT JS files, $CSS_COUNT CSS files"
            else
              echo "   ‚ùå ERROR: static/_next directory not found - CSS/JS won't load!"
              echo "   Listing static directory contents:"
              ls -la .vercel/output/static/ | head -10
              exit 1
            fi
          fi

          echo ""
          echo "üìÅ App Router chunks (sanity check):"
          if [ -d ".vercel/output/_next/static/chunks/app" ]; then
            echo "‚úÖ Found app chunks directory"
            echo "   Dashboard-related chunks:"
            find .vercel/output/_next/static/chunks/app -type f 2>/dev/null | grep -i dashboard | head -50 || echo "   (none)"
            echo ""
            echo "   Page-related chunks:"
            find .vercel/output/_next/static/chunks/app -type f 2>/dev/null | grep -i \"app/page\" | head -20 || true
          else
            echo "‚ö†Ô∏è  No app chunks directory found at .vercel/output/_next/static/chunks/app"
            echo "   Listing chunks directory:"
            ls -la .vercel/output/_next/static/chunks/ | head -50 || true
          fi

          echo ""
          echo "üìÑ .vercel/output/config.json (routes excerpt):"
          if [ -f ".vercel/output/config.json" ]; then
            echo "‚úÖ config.json exists"
            echo "   Looking for 'routes' and 'overrides' keys:"
            grep -n '\"routes\"\\|\"overrides\"\\|\"functions\"\\|\"rewrites\"' .vercel/output/config.json | head -200 || true
            echo ""
            echo "   First 120 lines:"
            sed -n '1,120p' .vercel/output/config.json
          else
            echo "‚ùå config.json missing"
          fi

      - name: Deploy to Cloudflare Pages (Converged)
        working-directory: apps/web
        run: |
          echo "üöÄ Deploying converged Workers + Pages project..."
          echo ""
          echo "   Project: micropaywall"
          echo "   Branch: ${{ github.ref_name }}"
          echo "   Commit: ${{ github.sha }}"
          echo ""
          echo "   Deploying with wrangler..."
          # Safely pass commit message via environment variable to prevent shell interpretation
          wrangler pages deploy .vercel/output \
            --project-name=micropaywall \
            --branch=${{ github.ref_name }} \
            --commit-hash=${{ github.sha }} \
            --commit-message="$COMMIT_MESSAGE"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

      - name: Purge Cloudflare Cache
        run: |
          echo "üßπ Purging Cloudflare cache to clear cached responses..."
          
          # Get zone ID from domain (micropaywall.app)
          ZONE_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=micropaywall.app" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json")
          
          ZONE_ID=$(echo "$ZONE_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"\([^"]*\)"/\1/')
          
          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = "null" ] || [ "$ZONE_ID" = "" ]; then
            echo "‚ö†Ô∏è  Could not find zone ID for micropaywall.app, skipping cache purge"
          else
            echo "   Found zone ID: $ZONE_ID"
            echo "   Purging cache..."
            PURGE_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/purge_cache" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d '{"purge_everything":true}')
            
            if echo "$PURGE_RESPONSE" | grep -q '"success":true'; then
              echo "‚úÖ Cache purged successfully"
            else
              echo "‚ö†Ô∏è  Cache purge may have failed. Response: $PURGE_RESPONSE"
            fi
          fi

